import json
import re
from application.ai.llm import actor_llm, director_llm
from application.play.actor import Actor
from application.play.director import Director
from application.play.player import Player

class Stage:
    def __init__(self, actors, director, player, plot_objectives, socketio=None):
        """
        actors: dict mapping actor names to Actor objects.
        director: a Director object (with check_objective method).
        player: a Player object.
        plot_objectives: list of plot objective strings.
        socketio: Socket.IO instance for real-time communication.
        """
        self.actors = actors
        self.director = director
        self.player = player
        self.plot_objectives = plot_objectives
        self.current_objective_index = 0
        self.context = ""
        self.plot_failure_reason = ''
        self.chat_summary = ''
        self.full_chat = ''
        self.last_script_data = None
        self.last_outline = None
        self.socketio = socketio
        self.dialogue_history = []

    def add_to_chat_history(self, text):
        if self.context:
            self.context += "\n" + text
        else:
            self.context = text

    def current_objective(self):
        if self.current_objective_index < len(self.plot_objectives):
            return self.plot_objectives[self.current_objective_index]
        return None
    
    def _clean_json(self, json_str):
        """
        Remove markdown fences and trailing commas from a JSON string.
        """
        cleaned = json_str.strip()
        # Remove markdown fences if present.
        if cleaned.startswith("```") and cleaned.endswith("```"):
            cleaned = cleaned.strip("```").strip()
            
        # Check if there's a json prefix line
        lines = cleaned.split("\n")
        if lines and lines[0].lower().startswith('json'):
            cleaned = "\n".join(lines[1:])
            
        # Remove trailing commas before a closing brace/bracket.
        cleaned = re.sub(r",\s*([\]}])", r"\1", cleaned)
        return cleaned

    def process_director_script(self, script_json):
        """
        Process the JSON script generated by the director.
        Emits dialogue lines through Socket.IO as they're processed.
        """        
        try:
            script_str = self._clean_json(script_json)
            script_data = json.loads(script_str)
        except Exception as e:
            self.emit_event('error', {"message": f"Error parsing director script JSON: {str(e)}"})
            script_data = {"scripts": []}
        
        dialogue_lines = []
        
        for line in script_data.get("scripts", []):
            role = line.get("role", "")
            # For actor lines, check for "instruction" then fallback to "content"
            instructions = line.get("instruction", "") or line.get("content", "")
                
            if role in self.actors:
                actor = self.actors[role]
                # Update the actor's chat_history dynamically before calling reply.
                reply_output = actor.reply(instructions, self.context)
                dialogue_line = f"{role}: {reply_output}"
                self.add_to_chat_history(dialogue_line)
                self.full_chat += "\n" + dialogue_line
                
                # Create dialogue entry for API response
                dialogue_entry = {
                    "role": role, 
                    "content": reply_output, 
                    "type": "actor_dialogue"
                }
                dialogue_lines.append(dialogue_entry)
                
                # Emit the dialogue line through Socket.IO if available
                self.emit_event('dialogue', dialogue_entry)
                
            elif role.lower() == "narration":
                content = line.get('content', instructions)
                dialogue_line = f"Narration: {content}"
                self.add_to_chat_history(dialogue_line)
                self.full_chat += "\n" + dialogue_line
                
                dialogue_entry = {
                    "role": "Narration", 
                    "content": content, 
                    "type": "narration"
                }
                dialogue_lines.append(dialogue_entry)
                self.emit_event('dialogue', dialogue_entry)
                
            else:
                # Unrecognized role; treat as narration.
                dialogue_line = f"{role}: {instructions}"
                self.add_to_chat_history(dialogue_line)
                self.full_chat += "\n" + dialogue_line
                
                dialogue_entry = {
                    "role": role, 
                    "content": instructions, 
                    "type": "other"
                }
                dialogue_lines.append(dialogue_entry)
                self.emit_event('dialogue', dialogue_entry)
        
        # Store the dialogue history for API access
        self.dialogue_history.extend(dialogue_lines)
        return dialogue_lines

    def advance_turn(self):
        """
        Advance the game turn based on the current objective.
        Returns dialogue lines generated during this turn.
        """
        objective = self.current_objective()
        if not objective:
            self.emit_event('status', {"message": "No current objective. Story complete."})
            return {"status": "complete", "message": "Story complete", "dialogue": []}

        self.emit_event('status', {"message": f"Advancing turn for plot objective: '{objective}'"})
        
        # Director generates an outline based on the current chat history and current plot objective
        outline_str = self.director.generate_outline(self.context, objective, self.plot_failure_reason)
        
        try:
            outline = json.loads(self._clean_json(outline_str))
            self.last_outline = outline
            self.chat_summary = outline.get('previous_outline')

            # Updating the background to include the summary and clearing the chat history to reduce context window
            self.context = ''
            self.director.background = self.chat_summary
            for actor in self.actors:
                self.actors[actor].background = self.chat_summary
                
            # Get the new outline from the result
            new_outline = outline.get('new_outline', outline)  # Fallback to the entire outline
            
            # Director generates turn instructions (script) based on the outline
            script_json = self.director.generate_turn_instructions(self.context, new_outline)
            self.last_script_data = script_json

            # Process the script and get the dialogue lines
            dialogue_lines = self.process_director_script(script_json)
            
        except Exception as e:
            error_msg = f"Error processing outline: {str(e)}"
            self.emit_event('error', {"message": error_msg})
            return {"status": "error", "message": error_msg, "dialogue": []}

        # Check if the objective has been reached using the director's check_objective method
        check_result_str = self.director.check_objective(self.full_chat, objective)
        objective_status = {}
        
        try:
            check_result = json.loads(self._clean_json(check_result_str))
            if check_result.get("completed", False):
                status_msg = f"Objective '{objective}' completed: {check_result.get('reason', '')}"
                self.current_objective_index += 1
                self.plot_failure_reason = ''
                objective_status = {
                    "completed": True,
                    "message": status_msg,
                    "reason": check_result.get('reason', '')
                }
            else:
                status_msg = f"Objective '{objective}' not yet completed: {check_result.get('reason', '')}"
                self.plot_failure_reason = 'Plot objective not met due to the following reason: ' + check_result.get('reason', '') + ' Please make the plot so it is addressed and the plot objective is completed'
                objective_status = {
                    "completed": False,
                    "message": status_msg,
                    "reason": check_result.get('reason', '')
                }
            
            self.emit_event('objective_status', objective_status)
            
        except Exception as e:
            error_msg = f"Error parsing objective check result: {str(e)}"
            self.emit_event('error', {"message": error_msg})
            objective_status = {
                "completed": False,
                "message": error_msg,
                "error": True
            }
        
        return {
            "status": "success",
            "dialogue": dialogue_lines,
            "objective": {
                "current": objective,
                "index": self.current_objective_index,
                "total": len(self.plot_objectives),
                "status": objective_status
            }
        }

    def player_interrupt(self, player_input):
        """
        Handle a player interruption.
        Returns dialogue lines generated after the interruption.
        """
        self.emit_event('status', {"message": "Player interrupts"})
        
        # Add the player's input to the chat history
        interrupt_line = f"{self.player.name}: {player_input}"
        self.add_to_chat_history(interrupt_line)
        
        # Add to dialogue history for frontend
        player_dialogue = {
            "role": self.player.name,
            "content": player_input,
            "type": "player_input"
        }
        self.dialogue_history.append(player_dialogue)
        self.emit_event('dialogue', player_dialogue)
        
        # After the interruption, ask the director to generate a new outline and script that includes the player's input
        current_obj = self.current_objective()
        if not current_obj:
            self.emit_event('status', {"message": "No current objective to continue after interruption."})
            return {"status": "error", "message": "No current objective", "dialogue": []}
            
        try:
            outline_str = self.director.generate_outline(self.context, current_obj)
            outline = json.loads(self._clean_json(outline_str))
            self.last_outline = outline
            
            new_outline = outline.get('new_outline', outline)  # Fallback to the entire outline
            
            script_json = self.director.generate_turn_instructions(self.context, new_outline)
            self.last_script_data = script_json
            
            dialogue_lines = self.process_director_script(script_json)
            
            return {
                "status": "success",
                "dialogue": dialogue_lines,
                "player_input": player_input
            }
            
        except Exception as e:
            error_msg = f"Error processing outline after interruption: {str(e)}"
            self.emit_event('error', {"message": error_msg})
            return {"status": "error", "message": error_msg, "dialogue": []}

    def get_state(self):
        """
        Get the current state of the stage for API responses.
        """
        return {
            "current_objective_index": self.current_objective_index,
            "total_objectives": len(self.plot_objectives),
            "current_objective": self.current_objective(),
            "plot_failure_reason": self.plot_failure_reason,
            "completed": self.current_objective_index >= len(self.plot_objectives),
            "dialogue_history": self.dialogue_history
        }
    
    def emit_event(self, event_type, data):
        """
        Emit an event through Socket.IO if available.
        """
        if self.socketio:
            self.socketio.emit(event_type, data)
            
    def run_sequence(self):
        """
        Run through the entire sequence of plot objectives.
        This is an API-friendly version of run_stage.
        """
        results = []
        while self.current_objective_index < len(self.plot_objectives):
            turn_result = self.advance_turn()
            results.append(turn_result)
            
        self.emit_event('status', {"message": "All plot objectives completed. The story ends here."})
        return {
            "status": "complete",
            "message": "All plot objectives completed",
            "results": results,
            "final_state": self.get_state()
        }



# import json
# import re
# from application.ai.llm import actor_llm,director_llm
# from application.play.actor import Actor
# from application.play.director import Director
# from application.play.player import Player

# class Stage:
#     def __init__(self, actors, director, player, plot_objectives):
#         """
#         actors: dict mapping actor names to Actor objects.
#         director: a Director object (with check_objective method).
#         player: a Player object.
#         plot_objectives: list of plot objective strings.
#         """
#         self.actors = actors
#         self.director = director
#         self.player = player
#         self.plot_objectives = plot_objectives
#         self.current_objective_index = 0
#         self.context = ""
#         self.plot_failure_reason=''
#         self.chat_summary=''
#         self.full_chat = ''
#         self.last_script_data = None
#         self.last_outline = None

#     def add_to_chat_history(self, text):
#         if self.context:
#             self.context += "\n" + text
#         else:
#             self.context = text

#     def current_objective(self):
#         if self.current_objective_index < len(self.plot_objectives):
#             return self.plot_objectives[self.current_objective_index]
#         return None
    
#     def _clean_json(self, json_str):
#         """
#         Remove markdown fences and trailing commas from a JSON string.
#         """
#         cleaned = json_str.strip()
#         # Remove markdown fences if present.
#         if cleaned.startswith("```") and cleaned.endswith("```"):
#             cleaned = cleaned.strip("`").strip()
            
#         # Check if there's a json prefix line
#         lines = cleaned.split("\n")
#         if lines and lines[0].lower().startswith('json'):
#             cleaned = "\n".join(lines[1:])
            
#         # Remove trailing commas before a closing brace/bracket.
#         cleaned = re.sub(r",\s*([\]}])", r"\1", cleaned)
#         return cleaned

#     def process_director_script(self, script_json):
#         """
#         Process the JSON script generated by the director.
#         Before processing each line, allow the player to interrupt.
#         For each line:
#           - If the player chooses to interrupt, call player_interrupt,
#             then break out of the current script processing.
#           - Otherwise, process the line as normal.
#         """        
#         try:
#             script_str = self._clean_json(script_json)
#             script_data = json.loads(script_str)
#         except Exception as e:
#             print("Error parsing director script JSON:", e)
#             script_data = {"scripts": []}
        
#         dialogue_lines = []
        
#         for line in script_data.get("scripts", []):
            
#             role = line.get("role", "")
#             # For actor lines, check for "instruction" then fallback to "content"
#             instructions = line.get("instruction", "") or line.get("content", "")
                
#             if role in self.actors:
#                 actor = self.actors[role]
#                 # Update the actor's chat_history dynamically before calling reply.
#                 reply_output = actor.reply(instructions, self.context)
#                 dialogue_line = f"{role}: {reply_output}"
#                 print(dialogue_line)
#                 self.add_to_chat_history(dialogue_line)
#                 self.full_chat += "\n" + dialogue_line
#                 dialogue_lines.append({role:reply_output})
#             elif role.lower() == "narration":
#                 dialogue_line = f"Narration: {line.get('content', instructions)}"
#                 print(dialogue_line)
#                 self.add_to_chat_history(dialogue_line)
#                 self.full_chat += "\n" + dialogue_line
#                 dialogue_lines.append({role:reply_output})
#             else:
#                 # Unrecognized role; treat as narration.
#                 dialogue_line = f"{role}: {instructions}"
#                 print(dialogue_line)
#                 self.add_to_chat_history(dialogue_line)
#                 self.full_chat += "\n" + dialogue_line
#                 dialogue_lines.append({role:reply_output})

#     def advance_turn(self):

#         objective = self.current_objective()
#         if not objective:
#             print("No current objective. Story complete.")
#             return

#         print(f"\n--- Advancing Turn for Plot Objective: '{objective}' ---")
#         # Director generates an outline based on the current chat history and current plot objective.
#         print(f"Current plot_failure_reason: {self.plot_failure_reason}")
#         outline_str = self.director.generate_outline(self.context, objective,self.plot_failure_reason)
        
#         try:
#             outline = json.loads(self._clean_json(outline_str))
#             print("Director Outline:")
#             print(outline)
#             self.chat_summary = outline.get('previous_outline')

#             # updating the background to include the summary and clearing the chat history to reduce context window
#             self.context=''
#             self.director.background = self.chat_summary
#             for actor in self.actors:
#                 self.actors[actor].background = self.chat_summary
#             # Get the new outline from the result
#             new_outline = outline.get('new_outline', outline)  # Fallback to the entire outline
            
#             # Director generates turn instructions (script) based on the outline.
#             script_json = self.director.generate_turn_instructions(self.context, new_outline)
#             print("Director Script Turn:")
#             print(script_json)

#             # Process the script, allowing for player interruptions during processing.
#             self.process_director_script(script_json)
#         except Exception as e:
#             print(f"Error processing outline: {e}")
#             print("Original outline string:")
#             print(outline_str)
#             return

#         # Check if the objective has been reached using the director's check_objective method.
#         print("\n--- Checking if Objective is Reached ---")
#         check_result_str = self.director.check_objective(self.full_chat, objective)
#         try:
#             check_result = json.loads(self._clean_json(check_result_str))
#             if check_result.get("completed", False):
#                 print(f"Objective '{objective}' completed: {check_result.get('reason', '')}")
#                 self.current_objective_index += 1
#                 self.plot_failure_reason = ''
#             else:
#                 print(f"Objective '{objective}' not yet completed: {check_result.get('reason', '')}")
#                 self.plot_failure_reason = 'Plot objective not met due to the following reason:' + check_result.get('reason') +'Please make the plot so it is addressed and the plot objective is completed'
#         except Exception as e:
#             print("Error parsing objective check result:", e)
#             print("Original check result string:")
#             print(check_result_str)

#     def player_interrupt(self, player_input):
#         print("\n--- Player Interrupts ---")
#         # Add the player's input to the chat history.
#         interrupt_line = f"{self.player.name}: {player_input}"  # Use player name instead of "Player"
#         print(interrupt_line)
#         self.add_to_chat_history(interrupt_line)
        
#         # After the interruption, ask the director to generate a new outline and script that includes the player's input.
#         current_obj = self.current_objective()
#         if not current_obj:
#             print("No current objective to continue after interruption.")
#             return
            
#         try:
#             outline_str = self.director.generate_outline(self.context, current_obj)
#             print("Director Outline after Player Interrupt:")
#             print(outline_str)
            
#             outline = json.loads(self._clean_json(outline_str))
#             new_outline = outline.get('new_outline', outline)  # Fallback to the entire outline
            
#             script_json = self.director.generate_turn_instructions(self.context, new_outline)
#             print("Director Script Turn after Player Interrupt:")
#             print(script_json)
#             self.process_director_script(script_json)
#         except Exception as e:
#             print(f"Error processing outline after interruption: {e}")
#             print("Original outline string:")
#             print(outline_str)

#     def run_stage(self):
#         while self.current_objective_index < len(self.plot_objectives):
#             self.advance_turn()
#             # Allow a final chance for player interruption at the end of each turn.
#             simulate_interrupt = input("\nEnter a player interrupt (or press Enter to continue to next turn): ")
#             if simulate_interrupt:
#                 self.player_interrupt(simulate_interrupt)
#         print("\nAll plot objectives completed. The story ends here.")
#         print("\nFinal Chat History:")
#         print(self.full_chat)





# # ---------------- Test Code ----------------
# if __name__ == "__main__":
#     # Sample initialization for Director.
#     show = "Friends"
#     description = "A show about 6 friends and their day to day life in new york."
#     background = "Chandler, joey and ross are sitting in central perk waiting for their coffee after a long day at work!"
#     actors_data = {
#         "Chandler": "chandler from the famous tv show friends.",
#         "Joey": "Joey from the famous tv show friends.",
#         "Ross": "Joey from the famous tv show friends."
#     }
#     relations = "Chandler is best friends with Joey, and Ross is Chandler's roommate."
#     player_description = "A person sharing a table with them due to over capacity in the cafe."

#     director = Director(director_llm,show,description, background, actors_data, player_description, relations)

#     # Sample initialization for Actors.
#     actors = {
#         "Chandler": Actor(
#             name="Chandler",
#             description="A sarcastic and witty character from a famous TV show.",
#             relations='{"Joey": "best friend", "Ross": "roommate"}',
#             background="At Central Perk with Joey and Ross.",
#             llm=actor_llm,
#         ),
#         "Joey": Actor(
#             name="Joey",
#             description="A charming and sometimes clueless friend.",
#             relations='{"Chandler": "best friend", "Ross": "friend"}',  # Fixed relation
#             background="At Central Perk enjoying a coffee.",
#             llm=actor_llm,
#         ),
#         "Ross": Actor(
#             name="Ross",
#             description="A caring friend who often finds himself in awkward situations.",
#             relations='{"Chandler": "friend", "Joey": "friend"}',  # Fixed relation
#             background="At Central Perk with Chandler and Joey.",
#             llm=actor_llm,
#         )
#     }

#     # Initialize the Player (you will participate directly).
#     player = Player(
#         name="Hritik",
#         description=player_description
#     )

#     # Define a list of plot objectives.
#     plot_objectives = [
#         "Ross tells a boring story about dinosaur and chandler starts roasting him about it.", 
#         "Ross becomes enraged at chandler for joking about dinosours.",  
#         "Joey stops chandler from making anymore jokes and chandler stops. Also joey calms ross down.",
#         "Ross and joey make chandler pay the coffee bill for making stupid jokes."
#     ]

#     # Initialize the Stage with actors, director, player, and plot objectives.
#     stage = Stage(actors=actors, director=director, player=player, plot_objectives=plot_objectives)

#     # Run the stage.
#     stage.run_stage()