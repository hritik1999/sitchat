import json
import re
from application.ai.llm import llm
from application.play.actor import Actor
from application.play.director import Director
from application.play.player import Player

class Stage:
    def __init__(self, actors, director, player, plot_objectives):
        """
        actors: dict mapping actor names to Actor objects.
        director: a Director object (with check_objective method).
        player: a Player object.
        plot_objectives: list of plot objective strings.
        """
        self.actors = actors
        self.director = director
        self.player = player
        self.plot_objectives = plot_objectives
        self.current_objective_index = 0
        self.chat_history = ""
        self.plot_failure_reason=''
        self.chat_summary=''
        self.full_chat = ''

    def add_to_chat_history(self, text):
        if self.chat_history:
            self.chat_history += "\n" + text
        else:
            self.chat_history = text

    def current_objective(self):
        if self.current_objective_index < len(self.plot_objectives):
            return self.plot_objectives[self.current_objective_index]
        return None
    
    def _clean_json(self, json_str):
        """
        Remove markdown fences and trailing commas from a JSON string.
        """
        cleaned = json_str.strip()
        # Remove markdown fences if present.
        if cleaned.startswith("```") and cleaned.endswith("```"):
            cleaned = cleaned.strip("`").strip()
            
        # Check if there's a json prefix line
        lines = cleaned.split("\n")
        if lines and lines[0].lower().startswith('json'):
            cleaned = "\n".join(lines[1:])
            
        # Remove trailing commas before a closing brace/bracket.
        cleaned = re.sub(r",\s*([\]}])", r"\1", cleaned)
        return cleaned

    def process_director_script(self, script_json):
        """
        Process the JSON script generated by the director.
        Before processing each line, allow the player to interrupt.
        For each line:
          - If the player chooses to interrupt, call player_interrupt,
            then break out of the current script processing.
          - Otherwise, process the line as normal.
        """        
        try:
            script_str = self._clean_json(script_json)
            script_data = json.loads(script_str)
        except Exception as e:
            print("Error parsing director script JSON:", e)
            script_data = {"scripts": []}
        
        for line in script_data.get("scripts", []):
            # Allow the player to interrupt before processing each line.
            interrupt_choice = input("\nPress 'i' to interrupt at this point or press Enter to continue: ")
            if interrupt_choice.lower() == 'i':
                player_input = input("Enter your interruption: ")
                self.player_interrupt(player_input)
                # After an interruption, halt further processing of the current script.
                return

            role = line.get("role", "")
            # For actor lines, check for "instruction" then fallback to "content"
            instructions = line.get("instruction", "") or line.get("content", "")
                
            if role in self.actors:
                actor = self.actors[role]
                # Update the actor's chat_history dynamically before calling reply.
                reply_output = actor.reply(instructions, self.chat_history)
                dialogue_line = f"{role}: {reply_output}"
                print(dialogue_line)
                self.add_to_chat_history(dialogue_line)
                self.full_chat += "\n" + dialogue_line
            elif role.lower() == "narration":
                dialogue_line = f"Narration: {line.get('content', instructions)}"
                print(dialogue_line)
                self.add_to_chat_history(dialogue_line)
                self.full_chat += "\n" + dialogue_line
            elif role.lower() == "player":
                reply_output = self.player.reply(instructions, self.chat_history)
                dialogue_line = f"{self.player.name}: {reply_output}"  # Use player name instead of "Player"
                print(dialogue_line)
                self.add_to_chat_history(dialogue_line)
                self.full_chat += "\n" + dialogue_line
            else:
                # Unrecognized role; treat as narration.
                dialogue_line = f"{role}: {instructions}"
                print(dialogue_line)
                self.add_to_chat_history(dialogue_line)
                self.full_chat += "\n" + dialogue_line

    def advance_turn(self):
        objective = self.current_objective()
        if not objective:
            print("No current objective. Story complete.")
            return

        print(f"\n--- Advancing Turn for Plot Objective: '{objective}' ---")
        # Director generates an outline based on the current chat history and current plot objective.
        outline_str = self.director.generate_outline(self.chat_history, objective,self.plot_failure_reason)
        
        try:
            outline = json.loads(self._clean_json(outline_str))
            print("Director Outline:")
            print(outline)
            self.chat_summary = outline.get('previous_outline')

            # updating the background to include the summary and clearing the chat history to reduce context window
            self.chat_history=''
            self.director.background = self.chat_summary
            for actor in self.actors:
                self.actors[actor].background = self.chat_summary
            # Get the new outline from the result
            new_outline = outline.get('new_outline', outline)  # Fallback to the entire outline
            
            # Director generates turn instructions (script) based on the outline.
            script_json = self.director.generate_turn_instructions(self.chat_history, new_outline)
            print("Director Script Turn:")
            print(script_json)

            # Process the script, allowing for player interruptions during processing.
            self.process_director_script(script_json)
        except Exception as e:
            print(f"Error processing outline: {e}")
            print("Original outline string:")
            print(outline_str)
            return

        # Check if the objective has been reached using the director's check_objective method.
        print("\n--- Checking if Objective is Reached ---")
        check_result_str = self.director.check_objective(self.full_chat, objective)
        try:
            check_result = json.loads(self._clean_json(check_result_str))
            if check_result.get("completed", False):
                print(f"Objective '{objective}' completed: {check_result.get('reason', '')}")
                self.current_objective_index += 1
                self.plot_failure_reason = ''
            else:
                print(f"Objective '{objective}' not yet completed: {check_result.get('reason', '')}")
                self.plot_failure_reason = 'Plot objective not met due to the following reason:' + check_result.get('reason') +'Please make the plot so it is addressed and the plot objective is completed'
        except Exception as e:
            print("Error parsing objective check result:", e)
            print("Original check result string:")
            print(check_result_str)

    def player_interrupt(self, player_input):
        print("\n--- Player Interrupts ---")
        # Add the player's input to the chat history.
        interrupt_line = f"{self.player.name}: {player_input}"  # Use player name instead of "Player"
        print(interrupt_line)
        self.add_to_chat_history(interrupt_line)
        
        # After the interruption, ask the director to generate a new outline and script that includes the player's input.
        current_obj = self.current_objective()
        if not current_obj:
            print("No current objective to continue after interruption.")
            return
            
        try:
            outline_str = self.director.generate_outline(self.chat_history, current_obj)
            print("Director Outline after Player Interrupt:")
            print(outline_str)
            
            outline = json.loads(self._clean_json(outline_str))
            new_outline = outline.get('new_outline', outline)  # Fallback to the entire outline
            
            script_json = self.director.generate_turn_instructions(self.chat_history, new_outline)
            print("Director Script Turn after Player Interrupt:")
            print(script_json)
            self.process_director_script(script_json)
        except Exception as e:
            print(f"Error processing outline after interruption: {e}")
            print("Original outline string:")
            print(outline_str)

    def run_stage(self):
        while self.current_objective_index < len(self.plot_objectives):
            self.advance_turn()
            # Allow a final chance for player interruption at the end of each turn.
            simulate_interrupt = input("\nEnter a player interrupt (or press Enter to continue to next turn): ")
            if simulate_interrupt:
                self.player_interrupt(simulate_interrupt)
        print("\nAll plot objectives completed. The story ends here.")
        print("\nFinal Chat History:")
        print(self.full_chat)





# ---------------- Test Code ----------------
if __name__ == "__main__":
    # Sample initialization for Director.
    show = "Friends"
    description = "A show about 6 friends and their day to day life in new york."
    background = "Chandler, joey and ross are sitting in central perk waiting for their coffee after a long day at work!"
    actors_data = {
        "Chandler": "chandler from the famous tv show friends.",
        "Joey": "Joey from the famous tv show friends.",
        "Ross": "Joey from the famous tv show friends."
    }
    relations = "Chandler is best friends with Joey, and Ross is Chandler's roommate."
    player_description = "A person sharing a table with them due to over capacity in the cafe."

    director = Director(llm,show,description, background, actors_data, player_description, relations)

    # Sample initialization for Actors.
    actors = {
        "Chandler": Actor(
            name="Chandler",
            description="A sarcastic and witty character from a famous TV show.",
            relations='{"Joey": "best friend", "Ross": "roommate"}',
            background="At Central Perk with Joey and Ross.",
            llm=llm,
        ),
        "Joey": Actor(
            name="Joey",
            description="A charming and sometimes clueless friend.",
            relations='{"Chandler": "best friend", "Ross": "friend"}',  # Fixed relation
            background="At Central Perk enjoying a coffee.",
            llm=llm,
        ),
        "Ross": Actor(
            name="Ross",
            description="A caring friend who often finds himself in awkward situations.",
            relations='{"Chandler": "friend", "Joey": "friend"}',  # Fixed relation
            background="At Central Perk with Chandler and Joey.",
            llm=llm,
        )
    }

    # Initialize the Player (you will participate directly).
    player = Player(
        name="Hritik",
        description=player_description
    )

    # Define a list of plot objectives.
    plot_objectives = [
        "Ross tells a boring story about dinosaur and chandler starts roasting him about it.", 
        "Ross becomes enraged at chandler for joking about dinosours.",  
        "Joey stops chandler from making anymore jokes and chandler stops. Also joey calms ross down.",
        "Ross and joey make chandler pay the coffee bill for making stupid jokes."
    ]

    # Initialize the Stage with actors, director, player, and plot objectives.
    stage = Stage(actors=actors, director=director, player=player, plot_objectives=plot_objectives)

    # Run the stage.
    stage.run_stage()