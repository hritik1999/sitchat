import json
import re
from application.ai.llm import llm
from application.play.actor import Actor  # Your Actor class
from application.play.director import Director  # Your Director class with check_objective method

class Player:
    def __init__(self, name, description):
        self.name = name
        self.description = description
        
    def reply(self):
        player_line = input("Your line: ")
        return player_line

class Stage:
    def __init__(self, actors, director, player, plot_objectives):
        """
        actors: dict mapping actor names to Actor objects.
        director: a Director object (with check_objective method).
        player: a Player object.
        plot_objectives: list of plot objective strings.
        """
        self.actors = actors
        self.director = director
        self.player = player
        self.plot_objectives = plot_objectives
        self.current_objective_index = 0
        self.chat_history = ""  # running dialogue/script

    def add_to_chat_history(self, text):
        if self.chat_history:
            self.chat_history += "\n" + text
        else:
            self.chat_history = text

    def current_objective(self):
        if self.current_objective_index < len(self.plot_objectives):
            return self.plot_objectives[self.current_objective_index]
        return None
    
    def _clean_json(self, json_str):
        """
        Remove markdown fences and trailing commas from a JSON string.
        """
        cleaned = json_str.strip()
        # Remove markdown fences if present.
        if cleaned.startswith("```") and cleaned.endswith("```"):
            cleaned = cleaned.strip("`").strip()
        # Remove trailing commas before a closing brace/bracket.
        cleaned = re.sub(r",\s*([\]}])", r"\1", cleaned)
        return cleaned

    def process_director_script(self, script_json):
        """
        Process the JSON script generated by the director.
        Before processing each line, allow the player to interrupt.
        For each line:
          - If the player chooses to interrupt, call player_interrupt,
            then break out of the current script processing.
          - Otherwise, process the line as normal.
        """        
        try:
            script_str = self._clean_json(script_json)
            script_data = json.loads(script_str)
        except Exception as e:
            print("Error parsing director script JSON:", e)
            script_data = {"scripts": []}
        
        for line in script_data.get("scripts", []):
            # Allow the player to interrupt before processing each line.
            interrupt_choice = input("\nPress 'i' to interrupt at this point or press Enter to continue: ")
            if interrupt_choice.lower() == 'i':
                player_input = input("Enter your interruption: ")
                self.player_interrupt(player_input)
                # After an interruption, halt further processing of the current script.
                return

            role = line.get("role", "")
            # For actor lines, check for "instruction" then fallback to "content"
            instructions = line.get("instruction") or line.get("content", "")
                
            if role in self.actors:
                actor = self.actors[role]
                # Update the actor's chat_history dynamically before calling reply.
                reply_output = actor.reply(instructions,self.chat_history)
                dialogue_line = f"{role}: {reply_output}"
                print(dialogue_line)
                self.add_to_chat_history(dialogue_line)
            elif role.lower() == "narration":
                dialogue_line = f"Narration: {line.get('content', instructions)}"
                print(dialogue_line)
                self.add_to_chat_history(dialogue_line)
            elif role.lower() == "player":
                reply_output = self.player.reply(instructions, self.chat_history)
                dialogue_line = f"Player: {reply_output}"
                print(dialogue_line)
                self.add_to_chat_history(dialogue_line)
            else:
                # Unrecognized role; treat as narration.
                dialogue_line = f"{role}: {instructions}"
                print(dialogue_line)
                self.add_to_chat_history(dialogue_line)

    def advance_turn(self):
        objective = self.current_objective()
        if not objective:
            print("No current objective. Story complete.")
            return

        print(f"\n--- Advancing Turn for Plot Objective: '{objective}' ---")
        # Director generates an outline based on the current chat history and current plot objective.
        outline = self.director.generate_outline(self.chat_history, objective)
        print("Director Outline:")
        outline = json.loads(self._clean_json(outline))
        print(outline)
        # Director generates turn instructions (script) based on the outline.
        script_json = self.director.generate_turn_instructions(self.chat_history,outline['new_outline'])
        print("Director Script Turn:")
        print(script_json)

        # Process the script, allowing for player interruptions during processing.
        self.process_director_script(script_json)

        # Check if the objective has been reached using the director's check_objective method.
        print("\n--- Checking if Objective is Reached ---")
        check_result_str = self.director.check_objective(self.chat_history, objective)
        print("Objective Check Result:")
        print(check_result_str)
        try:
            check_result = json.loads(check_result_str)
            if check_result.get("completed", False):
                print(f"Objective '{objective}' completed: {check_result.get('reason', '')}")
                self.current_objective_index += 1
            else:
                print(f"Objective '{objective}' not yet completed: {check_result.get('reason', '')}")
        except Exception as e:
            print("Error parsing objective check result:", e)

    def player_interrupt(self, player_input):
        print("\n--- Player Interrupts ---")
        # Add the player's input to the chat history.
        interrupt_line = f"Player: {player_input}"
        print(interrupt_line)
        self.add_to_chat_history(interrupt_line)
        # After the interruption, ask the director to generate a new outline and script that includes the player's input.
        current_obj = self.current_objective()
        if not current_obj:
            print("No current objective to continue after interruption.")
            return
        outline = self.director.generate_outline(self.chat_history, current_obj)
        print("Director Outline after Player Interrupt:")
        print(outline)
        script_json = self.director.generate_turn_instructions(self.chat_history, outline)
        print("Director Script Turn after Player Interrupt:")
        print(script_json)
        self.process_director_script(script_json)

    def run_stage(self):
        while self.current_objective_index < len(self.plot_objectives):
            self.advance_turn()
            # Allow a final chance for player interruption at the end of each turn.
            simulate_interrupt = input("\nEnter a player interrupt (or press Enter to continue to next turn): ")
            if simulate_interrupt:
                self.player_interrupt(simulate_interrupt)
        print("\nAll plot objectives completed. The story ends here.")
        print("\nFinal Chat History:")
        print(self.chat_history)

# ---------------- Test Code ----------------
if __name__ == "__main__":
    # Sample initialization for Director.
    show = "Friends"
    description = "A show about 6 friends and their day to day life in new york."
    background = "Chandler, joey and ross are sitting in central perk waiting for their coffee after a long day at work!"
    actors_data = {
        "Chandler": "A sarcastic character from a famous TV show.",
        "Joey": "A lovable, goofy friend.",
        "Ross": "A somewhat awkward yet caring friend."
    }
    relations = "Chandler is best friends with Joey, and Ross is Chandler's roommate."
    player_description = "A person sharing a table with them due to over capacity in the cafe."

    director = Director(show, description, background, actors_data, player_description, relations)

    # Sample initialization for Actors.
    actors = {
        "Chandler": Actor(
            name="Chandler",
            description="A sarcastic and witty character from a famous TV show.",
            relations='{"Joey": "best friend", "Ross": "roommate"}',
            background="At Central Perk with Joey and Ross.",
            llm=llm,
        ),
        "Joey": Actor(
            name="Joey",
            description="A charming and sometimes clueless friend.",
            relations='{"Chandler": "best friend", "Ross": "roommate"}',
            background="At Central Perk enjoying a coffee.",
            llm=llm,
        ),
        "Ross": Actor(
            name="Ross",
            description="A caring friend who often finds himself in awkward situations.",
            relations='{"Chandler": "roommate", "Joey": "best friend"}',
            background="At Central Perk with Chandler and Joey.",
            llm=llm,
        )
    }

    # Initialize the Player (you will participate directly).
    player = Player(
        name="Hritik",
        description=player_description
    )

    # Define a list of plot objectives.
    plot_objectives = [
        "Ross tells a boring story about dinosours and chandler roasts him hurting ross",
        "Joey tries to patch them and stop them from fighting!",
        "The all make up enjoy the coffee."
    ]

    # Initialize the Stage with actors, director, player, and plot objectives.
    stage = Stage(actors=actors, director=director, player=player, plot_objectives=plot_objectives)

    # Run the stage.
    stage.run_stage()
